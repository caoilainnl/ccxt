import * as fs from 'fs';
import ccxt from '../../js/ccxt.js';

const tsExchangeFile: string = '../ts/src/base/Exchange.ts';
const tsTypesFile: string = '../ts/src/base/types.ts';
const swiftExchangeFile: string = '../swift-wrapper/Sources/CCXTSwift/CCXTExchange.swift';
const swiftExchangesFile: string = '../swift-wrapper/Sources/CCXTSwift/CCXTExchanges.swift';
const swiftTypesFile: string = '../swift-wrapper/Sources/CCXTSwift/CCXTTypes.swift';
const goExchangeFile: string = '../go/v4/exchange_generated.go'
const goTypesFile: string = '../go/v4/exchange_types.go'
const gowrapperFile: string = '../swift-wrapper/ccxtwrapper.go';

const generatedHeader = `// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

`;

function capitalizeFirstLetter (methodName: string) {
    return methodName.charAt(0).toUpperCase() + methodName.slice(1);
}

function tsTypeToSwift(tsType: string): string {
    if (!tsType) return "Void";

    /* 1) [A,B][] → [(A, B)] */
    const tupArr = tsType.match(/^\s*\[([^,\]]+),\s*([^,\]]+)]\s*\[\]\s*$/);
    if (tupArr) {
        const a = tsTypeToSwift(tupArr[1].trim());
        const b = tsTypeToSwift(tupArr[2].trim());
        return `[(${a}, ${b})]`;
    }

    /* 2) T[], T[][], T[][][] → [T], [[T]], [[[T]]] */
    const arrayDepthMatch = tsType.match(/^(\w+)((\[\])+)\s*$/);
    if (arrayDepthMatch) {
        const baseType = arrayDepthMatch[1];
        const brackets = arrayDepthMatch[2];
        const depth = (brackets.match(/\[\]/g) || []).length;

        let inner = tsTypeToSwift(baseType);
        for (let i = 0; i < depth; i++) {
            inner = `[${inner}]`;
        }
        return inner;
    }

    /* 3) fixed-length tuple [T, U, …] → (T, U, …) */
    const tupleMatch = tsType.match(/^\[\s*([^,\]]+\s*,\s*[^,\]]+.*?)\s*\]$/);
    if (tupleMatch) {
        const inner = tupleMatch[1]
            .split(",")
            .map(p => tsTypeToSwift(p.trim()))
            .join(", ");
        return `(${inner})`;
    }

    /* 4) collapse Partial<X> → X (stand-alone or inside unions) */
    tsType = tsType.replace(/Partial<\s*([^>]+?)\s*>/g, "$1");

    /* helper for a single (non-union) token */
    const mapSingle = (t: string): string =>
        t
            .replace(/\bobject\b/g, "[String: Any]")
            .replace(/\bnumber\b/g, "Double")
            .replace(/\bstring\b/g, "String")
            .replace(/\bboolean\b/g, "Bool")
            .replace(/\bany\b/g, "Any")
            .replace(/\bundefined\b/g, "Any")
            .replace(/\bnull\b/g, "Any")
            .replace(/\bvoid\b/g, "Void")
            .replace(/Dictionary<([^>]+)>/g, "[String: $1]")
            .replace(/\bDict\b/g, "[String: Any]")
            .replace(/\bNullableDict\b/g, "[String: Any]?")
            .replace(/\bList\b/g, "[Any]")
            .replace(/\bNullableList\b/g, "[Any]?")
            .replace(/\bNum\b/g, "Double?")
            .replace(/\bInt\b/g, "Int?")
            .replace(/\bint\b/g, "Int")
            .replace(/\bStr\b/g, "String?")
            .replace(/\bStrings\b/g, "[String]?")
            .replace(/\bBool\b/g, "Bool?")
            .replace(/\bIndexType\b/g, "Any")
            .replace(/\bOrderSide\b/g, "String")
            .replace(/\bOrderType\b/g, "String")
            .replace(/\bMarketType\b/g, "String")
            .replace(/\bSubType\b/g, "String?")
            .trim();

    /* 5) handle unions */
    if (tsType.includes("|")) {
        const parts = tsType.split("|").map(p => p.trim());

        const isLit   = (p: string) => /^'[^']*'$/.test(p);
        const isStrKw = (p: string) => p === "string";
        const isStrAl = (p: string) => p === "Str";
        const isUndef = (p: string) => p === "undefined";
        const isNull  = (p: string) => p === "null";
        const isStrAr = (p: string) => p === "string[]";

        if (parts.every(p => isLit(p) || isStrKw(p) || isStrAl(p) || isUndef(p) || isNull(p))) {
            return parts.some(isUndef) || parts.some(isNull) ? "String?" : "String";
        }

        if (parts.every(p => isStrAr(p) || isUndef(p) || isNull(p))) {
            return "[String]?";
        }

        if (parts.length === 2 && (parts.some(isUndef) || parts.some(isNull))) {
            const base = parts.find(p => !isUndef(p) && !isNull(p))!;
            const mapped = mapSingle(base);
            return mapped.endsWith("?") ? mapped : `${mapped}?`;
        }

        if (parts.every(p => p === "number" || p === "string" || isUndef(p) || isNull(p))) {
            return "Any";
        }

        return "Any";
    }

    /* 6) single token */
    return mapSingle(tsType);
}

function createSwiftTypes() {
    const tsContent = fs.readFileSync(tsTypesFile, "utf8");
    const lines     = tsContent.split("\n");

    const excluded = new Set([
        "Int", "int", "Str", "Bool", "Dictionary", "Dict", "List",
    ]);

    const out: string[] = [];
    const stack: { name: string }[] = [];
    let indent = "";
    let braceDepth = 0;
    let skipDictBody = false;   // inside  extends Dictionary<...> { ... }
    let skipTypeBody = false;   // inside  Partial<X> & { ... }

    // TODO: look at renaming this variable again
    /* helper: rename reserved 'internal' → 'isInternal' */
    const rename = (n: string) => (n === "internal" ? "isInternal" : n);

    const push = (name: string) => {
        indent = "    ".repeat(stack.length);
        out.push(`${indent}public struct ${name} {`);
        stack.push({ name });
        indent = "    ".repeat(stack.length);
        braceDepth++;
    };
    const pop = () => {
        if (!stack.length) return;
        stack.pop();
        indent = "    ".repeat(stack.length);
        out.push(`${indent}}`);
        braceDepth--;
    };

    for (const raw of lines) {
        let line = raw.trim();
        if (!line) continue;

        /* skip bodies of dictionary-alias or partial-alias */
        if (skipDictBody) {
            if (line.startsWith("}")) skipDictBody = false;
            continue;
        }
        if (skipTypeBody) {
            if (line.startsWith("};") || line === "}") skipTypeBody = false;
            continue;
        }

        /* ── export type (one line) ─────────────────────────── */
        const oneType = line.match(/^export\s+type\s+(\w+)\s*=\s*(.+);$/);
        if (oneType) {
            const name = oneType[1];
            let body   = oneType[2].trim();
            const p = body.match(/^Partial<\s*([^>]+?)\s*>\s*&/);
            if (p) body = p[1].trim();
            body = body.replace(/\s*&\s*\{[\s\S]*$/, "").trim();
            if (!excluded.has(name))
                out.push(`public typealias ${name} = ${tsTypeToSwift(body)}`);
            continue;
        }

        /* ── export type Name = Partial<X> & {  (multi-line) ─── */
        const openPartial = line.match(
            /^export\s+type\s+(\w+)\s*=\s*Partial<\s*([^>]+?)\s*>\s*&\s*\{$/
        );
        if (openPartial) {
            const alias = openPartial[1];
            const base  = openPartial[2].trim();
            if (!excluded.has(alias))
                out.push(`public typealias ${alias} = ${tsTypeToSwift(base)}`);
            skipTypeBody = true;
            continue;
        }

        /* ── interface Name extends Dictionary<T> { … } ─────── */
        const dict = line.match(
            /^export\s+interface\s+(\w+)\s+extends\s+Dictionary\s*<\s*([^>]+?)\s*>\s*(\{)?\s*$/
        );
        if (dict) {
            const alias = dict[1];
            const inner = tsTypeToSwift(dict[2].trim());
            if (!excluded.has(alias))
                out.push(`public typealias ${alias} = [String: ${inner}]`);
            if (dict[3] === "{") skipDictBody = true;
            continue;
        }

        /* ── interface start (export optional) ───────────────── */
        const iface = line.match(/^(?:export\s+)?interface\s+(\w+)/);
        if (iface) {
            const name = iface[1];
            if (!excluded.has(name)) push(name);
            continue;
        }

        /* ── nested object  'foo': {  ───────────────────────── */
        const obj = line.match(/^['"]?(\w+)['"]?\??:\s*\{$/);
        if (obj) {
            const field = rename(obj[1]);
            const structName = field[0].toUpperCase() + field.slice(1);
            if (braceDepth === stack.length)
                out.push(`${indent}public var ${field}: ${structName}`);
            push(structName);
            continue;
        }

        /* ── closing brace ──────────────────────────────────── */
        if (line.startsWith("}")) {
            pop();
            continue;
        }

        /* ── ordinary field ( ; or , ) ─────────────────────── */
        const fld = line.match(/^['"]?(\w+)['"]?\??:\s*([^;,]+)[;,]?$/);
        if (fld && stack.length) {
            const name      = rename(fld[1]);
            const swiftType = tsTypeToSwift(fld[2]);
            const optional  = fld[0].includes("?") || swiftType.endsWith("?");
            out.push(`${indent}public var ${name}: ${swiftType}${optional ? "" : ""}`);
        }
    }

    /* write generated Swift types */
    
    fs.writeFileSync(swiftTypesFile, generatedHeader, "utf8");
    fs.appendFileSync(swiftTypesFile, out.join("\n"), "utf8");
}

function getMethodHeaders(): [string, string][] {
    const src = fs.readFileSync(tsExchangeFile, "utf8");

    /* async foo (…) : Promise<Return> */
    const methodRE =
        /^\s*async\s+(\w+)\s*\(([\s\S]*?)\)\s*(?::\s*Promise\s*<\s*([\w\[\]]+)\s*>)?/gm;

    const matches = [...src.matchAll(methodRE)];
    const result: [string, string][] = [];

    for (const m of matches) {
        const methodName  = m[1].trim();
        const rawArgs     = m[2].trim();
        const tsReturn    = m[3]?.trim() ?? "Any";
        const swiftReturn = tsTypeToSwift(tsReturn);

        if (!rawArgs) {
            result.push([`${methodName}()`, swiftReturn]);
            continue;
        }

        /* split on commas that are NOT inside {...} or [...] */
        const argParts = rawArgs.split(/,(?![^{]*})(?![^\[]*\])/).map(s => s.trim()).filter(Boolean);

        const swiftArgs = argParts.map(part => {
            /* name [ ? ] : type [ = default ] |  name = default */
            const argRE =
                /^\s*(['"]?[\w$]+['"]?)\s*(\?)?\s*(?::\s*([^=]+?))?\s*(?:=\s*(.*))?\s*$/;
            const a = part.match(argRE);
            if (!a) return part.trim();          // fallback

            let [ , nameRaw, qmark, tsType, defVal ] = a;
            const name = nameRaw.replace(/^['"]|['"]$/g, ""); // strip quotes
            tsType = tsType?.trim() || "any";

            let swiftType = tsTypeToSwift(tsType);
            let finalDefault: string | undefined;

            if (defVal !== undefined) {
                let cleanedDefault = defVal.trim()
                    .replace(/'/g, '"')
                    .replace(/\bundefined\b/g, "nil")
                    .replace(/\bnull\b/g, "nil");

                if (cleanedDefault === "{}") {
                    cleanedDefault = "[:]";
                }

                if (cleanedDefault === "nil" && !swiftType.endsWith("?")) {
                    swiftType += "?";
                }

                const isStringType = swiftType === "String" || swiftType === "String?";
                const needsQuotes = isStringType && !/^".*"$/.test(cleanedDefault) && cleanedDefault !== "nil" && cleanedDefault !== "[:]";

                finalDefault = needsQuotes ? `"${cleanedDefault}"` : cleanedDefault;
            }

            return finalDefault !== undefined
                ? `${name}: ${swiftType} = ${finalDefault}`
                : `${name}: ${swiftType}`;
        }).join(", ");

        result.push([`${methodName}(${swiftArgs})`, swiftReturn]);
    }

    return result;
}

function transformSwiftHeaderToGo(swiftHeader: string): string {
    // 1. Remove "public", "throws", "-> Any" (or -> AnyType)
    let header = swiftHeader
        .replace(/^public\s+/, '')
        .replace(/\s+throws/, '')
        .replace(/\s*->\s*\w+\s*\{/, '{');  // removes "-> Any {" or "-> SomeType {"

    // 2. Extract method name and parameter list
    const match = header.match(/^func\s+(\w+)\s*\((.*?)\)\s*(?:->\s*.+?)?\s*\{/);
    if (!match) {
        console.log(header);
        throw new Error("Invalid Swift method header format");
    }

    const methodName = match[1];
    const paramList = match[2].trim();

    // 3. Process parameters
    const goParams = paramList
        ? paramList.split(/,(?![^{]*})(?![^\[]*\])/).map(param => {
            const paramParts = param.trim().match(/^(\w+)\s*:/);
            if (!paramParts) return null;

            let paramName = paramParts[1];

            // Rename "type" → "typeVar"
            if (paramName === "type") {
                paramName = "typeVar";
            }

            // Special case for "params"
            if (paramName === "params") {
                return `${paramName} ...interface{}`;
            } else {
                return `${paramName} interface{}`;
            }
        }).filter(p => p !== null).join(', ')
        : '';

    // 4. Build Go method header
    const goHeader = `func (e *Exchange) ${methodName}(${goParams}) ([]byte, error) {`;

    return goHeader;
}

function getMethodNames(): string[] {
    const exchange = new ccxt.Exchange();
    return Object.keys(exchange.has);    //.map(methodName => capitalizeFirstLetter(methodName));
}

const goMethodDeclaration = (header: string, methodCall: string) => (`
${header}
    res := <-e.exchange.${capitalizeFirstLetter(methodCall)}
    if err, ok := res.(error); ok {
        return nil, err
    }
    return json.Marshal(res)
}`
)

const swiftMethodDeclaration = (header: string, methodCall: string, returnType: string, methodName: string) => (`
    ${header}
        do {
            let data = try exchange.${methodCall}
            let jsonObject = try JSONSerialization.jsonObject(with: data, options: [])
            guard let result = cleanAny(jsonObject) as? ${returnType} else {
                throw NSError(domain: "CCXT", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid response type for ${methodName}"])
            }
            return result
        } catch {
            throw error
        }
    }
`)

const exchangeDeclaration = (exchangeName: string) => (`
public class ${capitalizeFirstLetter(exchangeName)} extends CCXTExchange {
    public init?(configJson: String) {
        guard let ex = CcxtNewExchange('${exchangeName}', configJson) else {
            return nil
        }
        self.exchange = ex
    }
}`);

function createExchangeClasses() {
    const exchangeDeclarations: string[] = [];
    for (const exchangeName of ccxt.exchanges) {
        exchangeDeclarations.push(exchangeDeclaration(exchangeName));
    }
    fs.writeFileSync(swiftExchangesFile, "import Foundation\nimport CCXT\n", "utf8");
    fs.appendFileSync(swiftExchangesFile, exchangeDeclarations.join("\n"), "utf8");
}

function main() {

    createSwiftTypes();
    createExchangeClasses();
    
    const methods = getMethodHeaders();
    const injectAfterString = '// METHODS BELOW THIS LINE ARE TRANSPILED';
    const injectAfterRegex = new RegExp(`(${injectAfterString})([\\s\\S]*)`, 'm');
    const swiftMethodDeclarations: string[] = [];
    const goMethodDeclarations: string[] = [];

    for (const [methodHeader, returnType] of methods) {
        const methodCall = methodHeader.replace(/(\w+)\s*:\s*[^),]+/g, '$1');
        const goMethodCall = methodCall.replace(/\btype\b(?=\s*[,)])/g, 'typeVar')
        const methodName = methodHeader.replace(/^\s*(?:async\s+)?(\w+)\s*\(.*$/, '$1');
        const swiftHeader = `public func ${methodHeader} throws -> ${returnType} {`
        swiftMethodDeclarations.push(swiftMethodDeclaration(swiftHeader, methodCall, returnType, methodName));
        goMethodDeclarations.push(goMethodDeclaration(transformSwiftHeaderToGo(swiftHeader), goMethodCall));
    }

    const loopItems: [string, string[]][] = [
        [swiftExchangeFile, swiftMethodDeclarations],
        [gowrapperFile, goMethodDeclarations]
    ];

    loopItems.forEach(([file, methodDeclarations]) => {
        const fileContent = fs.readFileSync(file, 'utf8');
        const newFileContent = fileContent.replace(
            injectAfterRegex,
            `$1\n${methodDeclarations.join('\n')}`
        ) + '\n}';
        fs.writeFileSync(file, newFileContent);
    })
}


main()
